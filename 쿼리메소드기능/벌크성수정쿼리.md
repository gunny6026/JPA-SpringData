## 벌크성 수정 쿼리

#### 순수 JPA

```java
  public int bulkAgePlus(int age){
       return em.createQuery(
                "update Member m set m.age = m.age +1 where m.age >= :age ")
                .setParameter("age",age)
                .executeUpdate();
    }
```

`테스트 케이스`

```java
  @Test
    public void bulkUpdate(){

//        Member member = new Member("멤버1",20);
//        Member member2 = new Member("멤버2",22);
//        Member member3 = new Member("멤버3",25);

        memberJpaRepository.save(new Member("member1",20));
        memberJpaRepository.save(new Member("member2",30));
        memberJpaRepository.save(new Member("member3",31));
        memberJpaRepository.save(new Member("member4",32));
        memberJpaRepository.save(new Member("member5",33));
        memberJpaRepository.save(new Member("member6",34));

        int i = memberJpaRepository.bulkAgePlus(33);

        assertThat(i).isEqualTo(2);


    }
```

#### 스프링 데이터 JPA

```java
    @Modifying
    @Query("update Member m set m.age = m.age +1 where m.age > :age")
    int bulkAgePlus(@Param("age") int age);
```

@Modifying 어노테이션이 필요하다.

이게 없으면 평소대로 getResultList() 이런 것을 리턴하고

있어야 executeUpdate()를 리턴 받을 수 있다.


`테스트 케이스`
```java
 @Test
    public void bulkUpdate(){


        memberRepository.save(new Member("member1",20));
        memberRepository.save(new Member("member2",30));
        memberRepository.save(new Member("member3",31));
        memberRepository.save(new Member("member4",32));
        memberRepository.save(new Member("member5",33));
        memberRepository.save(new Member("member6",34));

        int i = memberRepository.bulkAgePlus(33);

        assertThat(i).isEqualTo(2);


    }
```
**********


벌크성 수정 쿼리는 영속성 컨텍스트를 무시하고

바로 DB로 쿼리를 날리는 것이기 때문에 조심해야한다.


```java
memberRepository.save(new Member("member5",33));
        memberRepository.save(new Member("member6",34));

        int i = memberRepository.bulkAgePlus(33);

        List<Member> result = memberRepository.findByUsername("member6");

        Member member = result.get(0);

        System.out.println("member = "+member);

```

여기서 출력한 member의 나이는???

34 이다.  DB 에는 35인데 ??

위에서 말한 것처럼 벌크성은 영속성 컨텍스트를 무시하기 때문에

update 쿼리를 바로 DB로 때리기 때문에

위에서 영속성 컨텍스트의 1차 캐시에 데이터가 있기 때문에

DB에서 select를 하지 않기 때문에 영속성 컨텍스트에 있는

데이터 34가 호출 된 것이다.

그렇기 때문에

```java
        memberRepository.save(new Member("member6",34));

        int i = memberRepository.bulkAgePlus(33);
        entityManager.flush();
        entityManager.clear();

        List<Member> result = memberRepository.findByUsername("member6");
```

영속성 컨텍스트에 있는 데이터를 flush로 DB로 날려버리고

clear를 해서 영속성 컨텍스트를 지워야한다.

아니면 스프링 데이터 JPA 에서는

```java
    @Modifying(clearAutomatically = true)
    @Query("update Member m set m.age = m.age +1 where m.age >= :age")
    int bulkAgePlus(@Param("age") int age);
```

clearAutomatically =true 설정을 해줘야한다.